name: Deploy to AWS ECS (Fargate)

on:
  # Manual deploy to avoid accidental AWS costs.
  workflow_dispatch:

# Required for GitHub OIDC -> AWS role assumption
permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-ecs-main
  cancel-in-progress: true

env:
  TASK_DEFINITION_TEMPLATE: infra/ecs/task-definition.json
  # Prefer Secrets, fall back to Actions Variables (Repo Settings -> Secrets and variables -> Actions)
  AWS_REGION: ${{ secrets.AWS_REGION || vars.AWS_REGION }}
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN || vars.AWS_ROLE_ARN }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required AWS settings
        run: |
          set -euo pipefail
          if [ -z "${AWS_REGION:-}" ]; then
            echo "Missing AWS region. Set Actions Secret AWS_REGION (recommended) or Actions Variable AWS_REGION."
            exit 1
          fi
          if [ -z "${AWS_ROLE_ARN:-}" ]; then
            echo "Missing AWS role ARN. Set Actions Secret AWS_ROLE_ARN (recommended) or Actions Variable AWS_ROLE_ARN."
            exit 1
          fi

      # TODO(you): Create an IAM Role in AWS that GitHub Actions can assume via OIDC.
      # Best practice is OIDC, not long-lived access keys.
      # Secrets you must add in GitHub (Repo Settings -> Secrets and variables -> Actions):
      # - AWS_REGION
      # - AWS_ROLE_ARN
      # - ECR_REPOSITORY (e.g. "colorsnap-app" from CDK output)
      # - ECS_CLUSTER (e.g. "colorsnap-cluster" from CDK output)
      # - ECS_SERVICE (e.g. "colorsnap-service" from CDK output)
      # - ECS_TASK_EXECUTION_ROLE_ARN (from CDK output TaskExecutionRoleArn)
      # - ECS_TASK_ROLE_ARN (from CDK output TaskRoleArn)
      #
      # If you don't want to set up OIDC yet:
      # - Replace this step with AWS_ACCESS_KEY_ID / AWS_SECRET_ACCESS_KEY secrets.
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          echo "Building image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          docker build -t "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" .
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          # Optional: also push :latest for convenience (not required for ECS deploy).
          docker tag "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" "$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          docker push "$ECR_REGISTRY/$ECR_REPOSITORY:latest"

      - name: Prepare task definition (fill in role ARNs + region)
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          EXEC_ROLE_ARN: ${{ secrets.ECS_TASK_EXECUTION_ROLE_ARN }}
          TASK_ROLE_ARN: ${{ secrets.ECS_TASK_ROLE_ARN }}
        run: |
          set -euo pipefail
          cp "$TASK_DEFINITION_TEMPLATE" task-definition.json
          sed -i "s|REPLACE_ME_EXECUTION_ROLE_ARN|$EXEC_ROLE_ARN|g" task-definition.json
          sed -i "s|REPLACE_ME_TASK_ROLE_ARN|$TASK_ROLE_ARN|g" task-definition.json
          sed -i "s|REPLACE_ME_AWS_REGION|$AWS_REGION|g" task-definition.json

      - name: Render Amazon ECS task definition (set image)
        id: render-task-definition
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: app
          image: ${{ steps.login-ecr.outputs.registry }}/${{ secrets.ECR_REPOSITORY }}:${{ github.sha }}

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-task-definition.outputs.task-definition }}
          service: ${{ secrets.ECS_SERVICE }}
          cluster: ${{ secrets.ECS_CLUSTER }}
          wait-for-service-stability: true


